// mceliece348864

module synd where

import helper
import params
import gf
import root

synd : [SYS_T_t + 1]gf_t -> [SYS_N_t]gf_t -> [SYS_N_t/8][8] -> [2*SYS_T_t]gf_t
synd f L r = last zss
  where zss = [zero] # [ synd_loop f li (c i) zs | zs <- zss | i <- [0 .. <SYS_N_t] | li <- L ]
        c i' = (zero # (r@(i'/8) >> (i'%8))) && (0x0001 : gf_t)
        
synd_loop : [SYS_T_t + 1]gf_t -> gf_t -> gf_t -> [2*SYS_T_t]gf_t -> [2*SYS_T_t]gf_t
synd_loop f li c in = [ gf_add z (gf_mul e_inv c) | z <- in | e_inv <- e_invs ]
  where e = eval f li
        e_inv_pre = gf_inv (gf_mul e e)
        e_invs = [e_inv_pre] # [ gf_mul e_inv li | e_inv <- e_invs ]

// This should be equivalent under the precondition c = 0x0000 || c = 0x0001, but I can't work
// out how to use this or prove it. Can prove it for either of these values!
// I can't seem to use zipWith here...

synd_loop_2 : [SYS_T_t + 1]gf_t -> gf_t -> gf_t -> [2*SYS_T_t]gf_t -> [2*SYS_T_t]gf_t
synd_loop_2 f li c in = [ gf_add z e_inv | z <- in | e_inv <- e_invs ]
  where e = eval f li
        e_inv_pre = gf_mul (gf_inv (gf_mul e e)) c
        e_invs = iterate (\x -> gf_mul x li) e_inv_pre

synd_unfolded : [SYS_T_t + 1]gf_t -> [SYS_N_t]gf_t -> [SYS_N_t] -> [2*SYS_T_t]gf_t
synd_unfolded f L r = last zss
  where zss = [zero] # [ if c then synd_loop_unfolded f li zs else zs | zs <- zss | li <- L | c <- r ]

synd_loop_unfolded : [SYS_T_t + 1]gf_t -> gf_t -> [2*SYS_T_t]gf_t -> [2*SYS_T_t]gf_t
synd_loop_unfolded f li in = [ gf_add z e_inv | z <- in | e_inv <- e_invs ]
  where e = eval f li
        e_inv_pre = gf_inv (gf_mul e e)
        e_invs = iterate (\x -> gf_mul x li) e_inv_pre

bytes_bits : [SYS_N_t/8][8] -> [SYS_N_t]
bytes_bits r = join (map reverse r) 

c_values : [SYS_N_t/8][8] -> [width (SYS_N_t - 1)] -> Bit
property  c_values r i = i < SYS_N ==> 
          c i == zero # [(bytes_bits r) @ i]
            where c i' = (zero # (r@(i'/8) >> (i'%8))) && (0x0001 : gf_t)

// Comment - another case where "case exhaustion" is useful.
property synd_loop_loop_2_eq f li in c = synd_loop_2 f li c in == synd_loop f li c in

property synd_loop_loop_2_eq_exhaust f li in = all (synd_loop_loop_2_eq f li in) [0x0000, 0x0001]

property synd_eq f L r = synd f L r == synd_unfolded f L (join (map reverse r))