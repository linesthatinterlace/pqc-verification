// mceliece248864
include "helper.saw";


// Module
linked_mod <- llvm_load_module "../src/linked.bc";

// Cry files
import "../specs/params.cry";
import "../specs/gf.cry";
import "../specs/util.cry";
import "../specs/root.cry";
import "../specs/util.cry";

// Params and Definitions

let SYS_T = eval_int {{SYS_T : [width SYS_T_t]}};
let SYS_N = eval_int {{SYS_N : [width SYS_N_t]}};

let gf_type = llvm_int 16;

/////////////// gf.c specs ///////////////

let gf_iszero_spec = do {
  // Initialise variable(s).
  a <- llvm_fresh_var "a" gf_type; 

  // Run function.
  llvm_execute_func [llvm_term a];
  let result = {{ gf_iszero a }};

  // Check output is GF correct.
  //llvm_postcond {{ gf_valid result }};

  // Result is equivalent to Cryptol function.
  llvm_return (llvm_term result);
};


let gf_add_spec = do {
  // Initialise variable(s).
  in0 <- llvm_fresh_var "in0" gf_type;
  in1 <- llvm_fresh_var "in1" gf_type;

  // Require that input(s) fit inside GBITS (to ensure correctness).
  //llvm_precond {{ gf_valid in0 }};
  //llvm_precond {{ gf_valid in1 }};

  // Run function.
  llvm_execute_func [llvm_term in0, llvm_term in1];
  let result = {{ gf_add in0 in1 }};

  // Check output is GF correct.
  //llvm_postcond {{ gf_valid result }};

  // Result is equivalent to Cryptol function.
  llvm_return (llvm_term result);
};

let gf_mul_spec = do {
  // Initialise variable(s).
  x <- llvm_fresh_var "in0" gf_type;
  y <- llvm_fresh_var "in1" gf_type;

  // Require that input(s) fit inside GBITS (to ensure correctness).
  //llvm_precond {{ gf_valid x }};
  //llvm_precond {{ gf_valid y }};

  // Run function.
  llvm_execute_func [llvm_term x, llvm_term y];
  let result = {{ gf_mul x y }};

  // Check output is GF correct.
  //llvm_postcond {{ gf_valid result }};

  // Result is equivalent to Cryptol function.
  llvm_return (llvm_term result);

};

let gf_sq_spec = do {
  // Initialise variable(s).
  x <- llvm_fresh_var "in" gf_type;

  // Require that input(s) fit inside GBITS (to ensure correctness).

  // Run function.
  llvm_execute_func [llvm_term x];
  let result = {{ gf_sq x }};

  // Check output is GF correct.
  //llvm_postcond {{ gf_valid result }};

  // Result is equivalent to Cryptol function.
  llvm_return (llvm_term result);
};


let gf_inv_spec = do {
  // Initialise variable(s).
  x <- llvm_fresh_var "in" gf_type;

  // Require that input(s) fit inside GBITS (to ensure correctness).
  //llvm_precond {{ gf_valid x }};

  // Run function.
  llvm_execute_func [llvm_term x];
  let result = {{ gf_inv x }};

  // Check output is GF correct.
  //llvm_postcond {{ gf_valid result }};

  // Result is equivalent to Cryptol function.
  llvm_return (llvm_term result);
};

let gf_frac_spec = do {
  // Initialise variable(s).
  x <- llvm_fresh_var "den" gf_type;
  y <- llvm_fresh_var "num" gf_type;

  // Require that input(s) fit inside GBITS (to ensure correctness).
  //llvm_precond {{ gf_valid x }};
  //llvm_precond {{ gf_valid y }};

  // Run function.
  llvm_execute_func [llvm_term x, llvm_term y];
  let result = {{ gf_frac x y }};

  // Check output is GF correct.
  //llvm_postcond {{ gf_valid result }};

  // Result is equivalent to Cryptol function.
  llvm_return (llvm_term result);
};

let GF_mul_spec = do {
  // Initialise variable(s).
  po <- llvm_alloc (llvm_array SYS_T gf_type);
  (x, px) <- ptr_to_fresh_readonly "in0" (llvm_array SYS_T gf_type);
  (y, py) <- ptr_to_fresh_readonly "in1" (llvm_array SYS_T gf_type);

  // Run function.
  llvm_execute_func [po, px, py];

  // Result is equivalent to Cryptol function.
  llvm_points_to po (llvm_term {{ (GF_mul x y) }});
};

let GF_mul_pre_reduce_spec = do {
  // Initialise variable(s).
  po <- llvm_alloc (llvm_array (eval_int {{2*SYS_T - 1 : [width 2*SYS_T_t - 1]}}) gf_type);
  (x, px) <- ptr_to_fresh_readonly "in0" (llvm_array SYS_T gf_type);
  (y, py) <- ptr_to_fresh_readonly "in1" (llvm_array SYS_T gf_type);

  // Run function.
  llvm_execute_func [po, px, py];

  // Result is equivalent to Cryptol function.
  llvm_points_to po (llvm_term {{ (GF_mul_pre_reduce x y) }});
};

let GF_mul_reduce_spec = do {
  // Initialise variable(s).
  po <- llvm_alloc (llvm_array SYS_T gf_type);
  (in_var, pin) <- ptr_to_fresh_readonly "in" (llvm_array (eval_int {{2*SYS_T - 1 : [width 2*SYS_T_t - 1]}}) gf_type);

  // Run function.
  llvm_execute_func [po, pin];

  // Result is equivalent to Cryptol function.
  llvm_points_to po (llvm_term {{ take`{64} (GF_mul_reduce in_var) }});
};

/////////////// root.c specs ///////////////

let eval_spec = do {
  // Initialise variable(s).
  (f, pf) <- ptr_to_fresh_readonly "f" (llvm_array (eval_int {{SYS_T + 1 : [width SYS_T_t + 1]}}) gf_type);
  a <- llvm_fresh_var "a" gf_type;

  //llvm_precond {{ gf_valid a }};
  //llvm_precond {{ all gf_valid f }};
  
    // Run function.
  llvm_execute_func [pf, llvm_term a];
  let result = {{ eval f a }};

  // Check output is GF correct.
  //llvm_postcond {{ gf_valid result }};

  // Result is equivalent to Cryptol function.
  llvm_return (llvm_term {{ eval f a }});
};

let root_spec = do {
  // Initialise variable(s).
  pout <- llvm_alloc (llvm_array SYS_N gf_type);
  (f, pf) <- ptr_to_fresh_readonly "f" (llvm_array (eval_int {{SYS_T + 1 : [width SYS_T_t + 1]}}) gf_type);
  (L, pL) <- ptr_to_fresh_readonly "L" (llvm_array SYS_N gf_type);

    // Require that input(s) fit inside GBITS (to ensure correctness).
  //llvm_precond {{ all gf_valid f }};
  //llvm_precond {{ all gf_valid L }};

  // Run function.
  llvm_execute_func [pout, pf, pL];

  // Result is equivalent to Cryptol function.
  llvm_points_to pout (llvm_term {{ root f L }});
};

/////////////// util.c specs ///////////////
let store_gf_spec = do {
  // Initialise variable(s).
  pdest <- llvm_alloc (llvm_array 2 (llvm_int 8));
  a <- llvm_fresh_var "a" gf_type;

  // Run function.
  llvm_execute_func [pdest, llvm_term a];

  // Result is equivalent to Cryptol function.
  llvm_points_to pdest (llvm_term {{ store_gf a }});
};

let load_gf_spec = do {
  // Initialise variable(s).
  (src, psrc) <- ptr_to_fresh_readonly "src" (llvm_array 2 (llvm_int 8));

  // Run function.
  llvm_execute_func [psrc];

  let result = {{ load_gf src }};

  // Check output is GF correct.
  //llvm_postcond {{ gf_valid result }};

  // Result is equivalent to Cryptol function.
  llvm_return (llvm_term result);
};

let load4_spec = do {
  // Initialise variable(s).
  (in_var, pin) <- ptr_to_fresh_readonly "in" (llvm_array 4 (llvm_int 8));

  // Run function.
  llvm_execute_func [pin];

  let result = {{ load4 in_var }};

  // Result is equivalent to Cryptol function.
  llvm_return (llvm_term result);
};

let store8_spec = do {
  // Initialise variable(s).
  pout <- llvm_alloc (llvm_array 8 (llvm_int 8));
  in_var <- llvm_fresh_var "in" (llvm_int 64);

  // Run function.
  llvm_execute_func [pout, llvm_term in_var];

  // Result is equivalent to Cryptol function.
  llvm_points_to pout (llvm_term {{ store8 in_var }});
};

let load8_spec = do {
  // Initialise variable(s).
  (in_var, pin) <- ptr_to_fresh_readonly "in" (llvm_array 8 (llvm_int 8));

  // Run function.
  llvm_execute_func [pin];

  let result = {{ load8 in_var }};

  // Result is equivalent to Cryptol function.
  llvm_return (llvm_term result);
};

let bitrev_spec = do {
  // Initialise variable(s).
  a <- llvm_fresh_var "a" gf_type; 

  // Run function.
  llvm_execute_func [llvm_term a];
  let result = {{ bitrev a }};

  // Check output is GF correct.
  //llvm_postcond {{ gf_valid result }};
  // Result is equivalent to Cryptol function.
  llvm_return (llvm_term result);
};

let main : TopLevel () = do {
  
  gf_iszero_ov <- llvm_verify linked_mod "gf_iszero" [] false gf_iszero_spec z3;
  gf_add_ov <- llvm_verify linked_mod "gf_add" [] false gf_add_spec z3;
  
  gf_mul_ov <- llvm_verify linked_mod "gf_mul" [] false gf_mul_spec z3;
  gf_sq_ov <- llvm_verify linked_mod "gf_sq" [] false gf_sq_spec z3;
  gf_inv_ov <- llvm_verify linked_mod "gf_inv" [gf_mul_ov, gf_sq_ov] false gf_inv_spec z3;
  gf_frac_ov <- llvm_verify linked_mod "gf_frac" [gf_mul_ov, gf_inv_ov] false gf_frac_spec z3;
  //GF_mul_pre_reduce_ov <- llvm_verify linked_mod "GF_mul_pre_reduce" [gf_mul_ov] false GF_mul_pre_reduce_spec (offline_smtlib2 "../pre_reduce");
  //GF_mul_reduce_ov <- llvm_verify linked_mod "GF_mul_reduce" [gf_mul_ov] false GF_mul_reduce_spec z3;
  //GF_mul_2_ov <- llvm_verify linked_mod "GF_mul_2" [GF_mul_pre_reduce_ov, GF_mul_reduce_ov] false GF_mul_spec z3;
  print "gf.c done (aside from GF_mul)!";
  
  eval_ov <- llvm_verify linked_mod "eval" [gf_add_ov, gf_mul_ov] false eval_spec z3;
  root_ov <- llvm_verify linked_mod "root" [eval_ov] true root_spec (unint_z3 ["root::eval"]);
  print "eval.c done!";
  

  store_gf_ov <- llvm_verify linked_mod "store_gf" [] false store_gf_spec abc;
  load_gf_ov <- llvm_verify linked_mod "load_gf" [] false load_gf_spec abc;
  load4_ov <- llvm_verify linked_mod "load4" [] false load4_spec abc;
  load8_ov <- llvm_verify linked_mod "load8" [] false load8_spec abc;
  store8_ov <- llvm_verify linked_mod "store8" [] false store8_spec abc;
  bitrev_ov <- llvm_verify linked_mod "bitrev" [] false bitrev_spec abc;
  print "util.c done!";
};


