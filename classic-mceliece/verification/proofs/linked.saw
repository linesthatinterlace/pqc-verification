// mceliece248864
include "helper.saw";

// Params and Definitions

let GBITS = 12;
let SYS_T = 64;
let SYS_T_plus_one = 65;
let SYS_N = 3488;

let gf_type = llvm_int 16;

// Module
linked_mod <- llvm_load_module "../src/linked.bc";

// Cry files
import "../specs/params.cry";
import "../specs/gf.cry";
import "../specs/util.cry";
import "../specs/root.cry";
import "../specs/util.cry";


/////////////// gf.c specs ///////////////

let gf_iszero_spec = do {
  // Initialise variable(s).
  a <- llvm_fresh_var "a" gf_type; 

  // Run function.
  llvm_execute_func [llvm_term a];
  let result = {{ gf_iszero a }};

  // Check output is GF correct.
  llvm_postcond {{ gf_valid result }};

  // Result is equivalent to Cryptol function.
  llvm_return (llvm_term result);
};


let gf_add_spec = do {
  // Initialise variable(s).
  in0 <- llvm_fresh_var "in0" gf_type;
  in1 <- llvm_fresh_var "in1" gf_type;

  // Require that input(s) fit inside GBITS (to ensure correctness).
  llvm_precond {{ gf_valid in0 }};
  llvm_precond {{ gf_valid in1 }};

  // Run function.
  llvm_execute_func [llvm_term in0, llvm_term in1];
  let result = {{ gf_add in0 in1 }};

  // Check output is GF correct.
  llvm_postcond {{ gf_valid result }};

  // Result is equivalent to Cryptol function.
  llvm_return (llvm_term result);
};

let gf_mul_spec = do {
  // Initialise variable(s).
  x <- llvm_fresh_var "in0" gf_type;
  y <- llvm_fresh_var "in1" gf_type;

  // Require that input(s) fit inside GBITS (to ensure correctness).
  //llvm_precond {{ gf_valid x }};
  //llvm_precond {{ gf_valid y }};

  // Run function.
  llvm_execute_func [llvm_term x, llvm_term y];
  let result = {{ gf_mul x y }};

  // Check output is GF correct.
  llvm_postcond {{ gf_valid result }};

  // Result is equivalent to Cryptol function.
  llvm_return (llvm_term result);

};

let gf_sq_spec = do {
  // Initialise variable(s).
  x <- llvm_fresh_var "in" gf_type;

  // Require that input(s) fit inside GBITS (to ensure correctness).
  llvm_precond {{ gf_valid x }};

  // Run function.
  llvm_execute_func [llvm_term x];
  let result = {{ gf_sq x }};

  // Check output is GF correct.
  llvm_postcond {{ gf_valid result }};

  // Result is equivalent to Cryptol function.
  llvm_return (llvm_term result);
};


let gf_inv_spec = do {
  // Initialise variable(s).
  x <- llvm_fresh_var "in" gf_type;

  // Require that input(s) fit inside GBITS (to ensure correctness).
  llvm_precond {{ gf_valid x }};

  // Run function.
  llvm_execute_func [llvm_term x];
  let result = {{ gf_inv x }};

  // Check output is GF correct.
  llvm_postcond {{ gf_valid result }};

  // Result is equivalent to Cryptol function.
  llvm_return (llvm_term result);
};

let gf_frac_spec = do {
  // Initialise variable(s).
  x <- llvm_fresh_var "den" gf_type;
  y <- llvm_fresh_var "num" gf_type;

  // Require that input(s) fit inside GBITS (to ensure correctness).
  llvm_precond {{ gf_valid x }};
  llvm_precond {{ gf_valid y }};

  // Run function.
  llvm_execute_func [llvm_term x, llvm_term y];
  let result = {{ gf_frac x y }};

  // Check output is GF correct.
  llvm_postcond {{ gf_valid result }};

  // Result is equivalent to Cryptol function.
  llvm_return (llvm_term result);
};

let GF_mul_spec = do {
  // Initialise variable(s).
  po <- llvm_alloc (llvm_array SYS_T gf_type);
  (x, px) <- ptr_to_fresh_readonly "in0" (llvm_array SYS_T gf_type);
  (y, py) <- ptr_to_fresh_readonly "in1" (llvm_array SYS_T gf_type);

  // Require that input(s) fit inside GBITS (to ensure correctness).
  llvm_precond {{ all gf_valid x }};
  llvm_precond {{ all gf_valid y }};
  // Run function.
  llvm_execute_func [po, px, py];

  // Result is equivalent to Cryptol function.
  llvm_points_to po (llvm_term {{ take`{SYS_T} ( GF_mul_no_reduce x y ) }});
};


/////////////// root.c specs ///////////////

let eval_spec = do {
  // Initialise variable(s).
  (f, pf) <- ptr_to_fresh_readonly "f" (llvm_array SYS_T_plus_one gf_type);
  a <- llvm_fresh_var "a" gf_type;

    // Require that input(s) fit inside GBITS (to ensure correctness).
  llvm_precond {{ all gf_valid f }};
  llvm_precond {{ gf_valid a }};

  // Run function.
  llvm_execute_func [pf, llvm_term a];

  // Result is equivalent to Cryptol function.
  llvm_return (llvm_term {{ eval f a }});
};

let root_spec = do {
  // Initialise variable(s).
  pout <- llvm_alloc (llvm_array SYS_N gf_type);
  (f, pf) <- ptr_to_fresh_readonly "f" (llvm_array SYS_T_plus_one gf_type);
  (L, pL) <- ptr_to_fresh_readonly "L" (llvm_array SYS_N gf_type);

    // Require that input(s) fit inside GBITS (to ensure correctness).
  llvm_precond {{ all gf_valid f }};
  llvm_precond {{ all gf_valid L }};

  // Run function.
  llvm_execute_func [pout, pf, pL];

  // Result is equivalent to Cryptol function.
  llvm_points_to pout (llvm_term {{ root f L }});
};

/////////////// util.c specs ///////////////
let store_gf_spec = do {
  // Initialise variable(s).
  pdest <- llvm_alloc (llvm_array 2 (llvm_int 8));
  a <- llvm_fresh_var "a" gf_type;

  // Run function.
  llvm_execute_func [pdest, llvm_term a];

  // Result is equivalent to Cryptol function.
  llvm_points_to pdest (llvm_term {{ store_gf a }});
};

let load_gf_spec = do {
  // Initialise variable(s).
  (src, psrc) <- ptr_to_fresh_readonly "src" (llvm_array 2 (llvm_int 8));

  // Run function.
  llvm_execute_func [psrc];

  let result = {{ load_gf src }};

  // Check output is GF correct.
  llvm_postcond {{ gf_valid result }};

  // Result is equivalent to Cryptol function.
  llvm_return (llvm_term result);
};

let load4_spec = do {
  // Initialise variable(s).
  (in_var, pin) <- ptr_to_fresh_readonly "in" (llvm_array 4 (llvm_int 8));

  // Run function.
  llvm_execute_func [pin];

  let result = {{ load4 in_var }};

  // Result is equivalent to Cryptol function.
  llvm_return (llvm_term result);
};

let store8_spec = do {
  // Initialise variable(s).
  pout <- llvm_alloc (llvm_array 8 (llvm_int 8));
  in_var <- llvm_fresh_var "in" (llvm_int 64);

  // Run function.
  llvm_execute_func [pout, llvm_term in_var];

  // Result is equivalent to Cryptol function.
  llvm_points_to pout (llvm_term {{ store8 in_var }});
};

let load8_spec = do {
  // Initialise variable(s).
  (in_var, pin) <- ptr_to_fresh_readonly "in" (llvm_array 8 (llvm_int 8));

  // Run function.
  llvm_execute_func [pin];

  let result = {{ load8 in_var }};

  // Result is equivalent to Cryptol function.
  llvm_return (llvm_term result);
};

let bitrev_spec = do {
  // Initialise variable(s).
  a <- llvm_fresh_var "a" gf_type; 

  // Run function.
  llvm_execute_func [llvm_term a];
  let result = {{ bitrev a }};

  // Check output is GF correct.
  llvm_postcond {{ gf_valid result }};

  // Result is equivalent to Cryptol function.
  llvm_return (llvm_term result);
};

let main : TopLevel () = do {
  
  gf_iszero_ov <- crucible_llvm_verify linked_mod "gf_iszero" [] false gf_iszero_spec abc;
  gf_add_ov <- crucible_llvm_verify linked_mod "gf_add" [] false gf_add_spec abc;
  
  gf_mul_ov <- crucible_llvm_verify linked_mod "gf_mul" [] false gf_mul_spec abc;
  gf_sq_ov <- crucible_llvm_verify linked_mod "gf_sq" [] false gf_sq_spec abc;
  gf_inv_ov <- crucible_llvm_verify linked_mod "gf_inv" [gf_mul_ov, gf_sq_ov] false gf_inv_spec abc;
  gf_frac_ov <- crucible_llvm_verify linked_mod "gf_frac" [gf_mul_ov, gf_inv_ov] false gf_frac_spec abc;
  //GF_mul_ov <- crucible_llvm_verify linked_mod "GF_mul" [gf_add_ov, gf_mul_ov] false GF_mul_spec abc;
  print "gf.c done (aside from GF_mul)!";

  /*
  eval_ov <- crucible_llvm_verify linked_mod "eval" [gf_add_ov, gf_mul_ov] false eval_spec abc;
  root_ov <- crucible_llvm_verify linked_mod "root" [eval_ov] true root_spec abc;
  print "eval.c done!";
  */

  store_gf_ov <- crucible_llvm_verify linked_mod "store_gf" [] false store_gf_spec abc;
  load_gf_ov <- crucible_llvm_verify linked_mod "load_gf" [] false load_gf_spec abc;
  load4_ov <- crucible_llvm_verify linked_mod "load4" [] false load4_spec abc;
  load8_ov <- crucible_llvm_verify linked_mod "load8" [] false load8_spec abc;
  store8_ov <- crucible_llvm_verify linked_mod "store8" [] false store8_spec abc;
  bitrev_ov <- crucible_llvm_verify linked_mod "bitrev" [] false bitrev_spec abc;
  print "util.c done!";
};


