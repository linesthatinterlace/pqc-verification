// mceliece248864
include "helper.saw";


// Module
linked_mod <- llvm_load_module "../src/linked.bc";

// Cry files
import "../specs/params.cry";
import "../specs/gf.cry";
import "../specs/util.cry";
import "../specs/root.cry";
import "../specs/synd.cry";

// Params and Definitions

let SYS_T = eval_int {{SYS_T : [width SYS_T_t]}};
let SYS_N = eval_int {{SYS_N : [width SYS_N_t]}};

let gf_type = llvm_int 16;

/////////////// gf.c specs ///////////////

let gf_iszero_spec = do {
  // Initialise variable(s).
  a <- llvm_fresh_var "a" gf_type; 

  // Run function.
  llvm_execute_func [llvm_term a];

  // Result is equivalent to Cryptol function.
  llvm_return (llvm_term {{ gf_iszero a }});
};


let gf_add_spec = do {
  // Initialise variable(s).
  in0 <- llvm_fresh_var "in0" gf_type;
  in1 <- llvm_fresh_var "in1" gf_type;

  // Run function.
  llvm_execute_func [llvm_term in0, llvm_term in1];

  // Result is equivalent to Cryptol function.
  llvm_return (llvm_term{{ gf_add in0 in1 }});
};

let gf_mul_spec = do {
  // Initialise variable(s).
  x <- llvm_fresh_var "in0" gf_type;
  y <- llvm_fresh_var "in1" gf_type;

  // Run function.
  llvm_execute_func [llvm_term x, llvm_term y];

  // Result is equivalent to Cryptol function.
  llvm_return (llvm_term {{ gf_mul x y }});

};

let gf_sq_spec = do {
  // Initialise variable(s).
  x <- llvm_fresh_var "in" gf_type;

  // Run function.
  llvm_execute_func [llvm_term x];

  // Result is equivalent to Cryptol function.
  llvm_return (llvm_term {{ gf_sq x }});
};


let gf_inv_spec = do {
  // Initialise variable(s).
  x <- llvm_fresh_var "in" gf_type;

  // Run function.
  llvm_execute_func [llvm_term x];

  // Result is equivalent to Cryptol function.
  llvm_return (llvm_term {{ gf_inv x }});
};

let gf_frac_spec = do {
  // Initialise variable(s).
  x <- llvm_fresh_var "den" gf_type;
  y <- llvm_fresh_var "num" gf_type;


  // Run function.
  llvm_execute_func [llvm_term x, llvm_term y];

  // Result is equivalent to Cryptol function.
  llvm_return (llvm_term {{ gf_frac x y }});
};

let GF_mul_spec = do {
  // Initialise variable(s).
  po <- llvm_alloc (llvm_array SYS_T gf_type);
  (x, px) <- ptr_to_fresh_readonly "in0" (llvm_array SYS_T gf_type);
  (y, py) <- ptr_to_fresh_readonly "in1" (llvm_array SYS_T gf_type);

  // Run function.
  llvm_execute_func [po, px, py];

  // Result is equivalent to Cryptol function.
  llvm_points_to po (llvm_term {{ GF_mul x y }});
};


/////////////// root.c specs ///////////////

let eval_spec = do {
  // Initialise variable(s).
  (f, pf) <- ptr_to_fresh_readonly "f" (llvm_array (eval_int {{SYS_T + 1 : [width (SYS_T_t + 1)]}}) gf_type);
  a <- llvm_fresh_var "a" gf_type;

  // Run function.
  llvm_execute_func [pf, llvm_term a];

  // Result is equivalent to Cryptol function.
  llvm_return (llvm_term {{ eval f a }});
};

let root_spec = do {
  // Initialise variable(s).
  pout <- llvm_alloc (llvm_array SYS_N gf_type);
  (f, pf) <- ptr_to_fresh_readonly "f" (llvm_array (eval_int {{SYS_T + 1 : [width (SYS_T_t + 1)]}}) gf_type);
  (L, pL) <- ptr_to_fresh_readonly "L" (llvm_array SYS_N gf_type);

  // Run function.
  llvm_execute_func [pout, pf, pL];

  // Result is equivalent to Cryptol function.
  llvm_points_to pout (llvm_term {{ root f L }});
};

/////////////// util.c specs ///////////////

let store_gf_spec = do {
  // Initialise variable(s).
  pdest <- llvm_alloc (llvm_array 2 (llvm_int 8));
  a <- llvm_fresh_var "a" gf_type;

  // Run function.
  llvm_execute_func [pdest, llvm_term a];

  // Result is equivalent to Cryptol function.
  llvm_points_to pdest (llvm_term {{ store_gf a }});
};

let load_gf_spec = do {
  // Initialise variable(s).
  (src, psrc) <- ptr_to_fresh_readonly "src" (llvm_array 2 (llvm_int 8));

  // Run function.
  llvm_execute_func [psrc];

  // Result is equivalent to Cryptol function.
  llvm_return (llvm_term {{ load_gf src }});
};

let load4_spec = do {
  // Initialise variable(s).
  (in_var, pin) <- ptr_to_fresh_readonly "in" (llvm_array 4 (llvm_int 8));

  // Run function.
  llvm_execute_func [pin];

  // Result is equivalent to Cryptol function.
  llvm_return (llvm_term {{ load4 in_var }});
};

let store8_spec = do {
  // Initialise variable(s).
  pout <- llvm_alloc (llvm_array 8 (llvm_int 8));
  in_var <- llvm_fresh_var "in" (llvm_int 64);

  // Run function.
  llvm_execute_func [pout, llvm_term in_var];

  // Result is equivalent to Cryptol function.
  llvm_points_to pout (llvm_term {{ store8 in_var }});
};

let load8_spec = do {
  // Initialise variable(s).
  (in_var, pin) <- ptr_to_fresh_readonly "in" (llvm_array 8 (llvm_int 8));

  // Run function.
  llvm_execute_func [pin];

  // Result is equivalent to Cryptol function.
  llvm_return (llvm_term {{ load8 in_var }});
};

let bitrev_spec = do {
  // Initialise variable(s).
  a <- llvm_fresh_var "a" gf_type; 

  // Run function.
  llvm_execute_func [llvm_term a];

  // Result is equivalent to Cryptol function.
  llvm_return (llvm_term {{ bitrev a }});
};

/////////////// synd.c specs ///////////////

let synd_spec = do {
  // Initialise variable(s).
  pout <- llvm_alloc (llvm_array (eval_int {{2*SYS_T : [width 2*SYS_T_t]}}) gf_type);
  (f, pf) <- ptr_to_fresh_readonly "f" (llvm_array (eval_int {{SYS_T + 1 : [width (SYS_T_t + 1)]}}) gf_type);
  (L, pL) <- ptr_to_fresh_readonly "L" (llvm_array SYS_N gf_type);
  (r, pr) <- ptr_to_fresh_readonly "r" (llvm_array (eval_int {{SYS_N/8 : [width SYS_N_t]}}) (llvm_int 8));

  // Run function.
  llvm_execute_func [pout, pf, pL, pr];

  // Result is equivalent to Cryptol function.
  llvm_points_to pout (llvm_term {{ synd f L r }});
};

let synd_loop_spec = do {
  // Initialise variable(s).
  (in_v, pin) <- ptr_to_fresh "in" (llvm_array (eval_int {{2*SYS_T : [width 2*SYS_T_t]}}) gf_type);
  (f, pf) <- ptr_to_fresh_readonly "f" (llvm_array (eval_int {{SYS_T + 1 : [width (SYS_T_t + 1)]}}) gf_type);
  li <- llvm_fresh_var "li" gf_type;
  c <- llvm_fresh_var "c" gf_type;

  // Run function.
  llvm_execute_func [pin, pf, llvm_term li, llvm_term c];

  // Result is equivalent to Cryptol function.
  llvm_points_to pin (llvm_term {{ synd_loop f li c in_v }});
};

let synd_loop_2_spec = do {
  // Initialise variable(s).
  (in_v, pin) <- ptr_to_fresh "in" (llvm_array (eval_int {{2*SYS_T : [width 2*SYS_T_t]}}) gf_type);
  li <- llvm_fresh_var "li" gf_type;
  e <- llvm_fresh_var "e" gf_type;

  // Run function.
  llvm_execute_func [pin, llvm_term li, llvm_term e];

  // Result is equivalent to Cryptol function.
  llvm_points_to pin (llvm_term {{ synd_loop_2 li e in_v }});
};

let synd_2_spec = do {
  // Initialise variable(s).
  pout <- llvm_alloc (llvm_array (eval_int {{2*SYS_T : [width 2*SYS_T_t]}}) gf_type);
  (f, pf) <- ptr_to_fresh_readonly "f" (llvm_array (eval_int {{SYS_T + 1 : [width (SYS_T_t + 1)]}}) gf_type);
  (L, pL) <- ptr_to_fresh_readonly "L" (llvm_array SYS_N gf_type);
  (r, pr) <- ptr_to_fresh_readonly "r" (llvm_array (eval_int {{SYS_N/8 : [width SYS_N_t]}}) (llvm_int 8));

  // Run function.
  llvm_execute_func [pout, pf, pL, pr];

  // Result is equivalent to Cryptol function.
  llvm_points_to pout (llvm_term {{ synd_2 f L r }});
};

/////////////// Proofs ///////////////

let main : TopLevel () = do {
  
  gf_iszero_ov <- llvm_verify linked_mod "gf_iszero" [] false gf_iszero_spec z3;
  gf_add_ov <- llvm_verify linked_mod "gf_add" [] false gf_add_spec z3;
  gf_mul_ov <- llvm_verify linked_mod "gf_mul" [] false gf_mul_spec z3;
  gf_sq_ov <- llvm_verify linked_mod "gf_sq" [] false gf_sq_spec z3;
  gf_inv_ov <- llvm_verify linked_mod "gf_inv" [gf_mul_ov, gf_sq_ov] false gf_inv_spec (unint_z3 ["gf_mul", "gf_sq"]);
  gf_frac_ov <- llvm_verify linked_mod "gf_frac" [gf_mul_ov, gf_inv_ov] false gf_frac_spec (unint_z3 ["gf_mul", "gf_inv"]);
  GF_mul_ov <- llvm_verify linked_mod "GF_mul" [gf_mul_ov] false GF_mul_spec (unint_z3 ["gf_mul"]);
  print "gf.c done!";
  
  eval_ov <- llvm_verify linked_mod "eval" [gf_add_ov, gf_mul_ov] false eval_spec (unint_z3 ["gf_add", "gf_mul"]);
  root_ov <- llvm_verify linked_mod "root" [eval_ov] true root_spec (unint_z3 ["eval"]);
  print "eval.c done!";

  store_gf_ov <- llvm_verify linked_mod "store_gf" [] false store_gf_spec z3;
  load_gf_ov <- llvm_verify linked_mod "load_gf" [] false load_gf_spec z3;
  load4_ov <- llvm_verify linked_mod "load4" [] false load4_spec z3;
  load8_ov <- llvm_verify linked_mod "load8" [] false load8_spec z3;
  store8_ov <- llvm_verify linked_mod "store8" [] false store8_spec z3;
  bitrev_ov <- llvm_verify linked_mod "bitrev" [] false bitrev_spec z3;
  print "util.c done!";

  //synd_loop_2_ov <- llvm_verify linked_mod "synd_loop_2" [gf_inv_ov, gf_add_ov, gf_mul_ov] false synd_loop_2_spec (unint_z3 ["gf_mul", "gf_inv", "gf_add"]);
  //synd_outer_2_ov <- llvm_verify linked_mod "synd_outer_2" [synd_loop_2_ov, root_ov] true synd_spec (unint_z3 ["root", "synd_loop_2_ov"]);
  synd_loop_ov <- llvm_verify linked_mod "synd_loop" [eval_ov, gf_inv_ov, gf_add_ov, gf_mul_ov] false synd_loop_spec (unint_z3 ["gf_mul", "gf_inv", "gf_add", "eval"]);
  synd_outer_ov <- llvm_verify linked_mod "synd_outer" [synd_loop_ov] false synd_spec (unint_z3 ["synd_loop_ov"]);
  print "synd.c done!";
};


